<html>
 <head></head>
 <body>
  <h1>Тема урока: работа с текстовыми файлами</h1> 
  <ol> 
   <li>Позиция (курсор) в файле</li> 
   <li>Менеджеры контекста</li> 
  </ol> 
  <p><strong>Аннотация.</strong>&nbsp;Урок посвящен&nbsp;работе&nbsp;с файлами: позиция считывания в файле, методы&nbsp;<code>seek(), tell()</code>, а также работа с менеджером контекста.</p> 
  <h2 style="text-align: center;">Позиция в файле</h2> 
  <p>Когда мы читаем текст из файла с помощью методов <code>read()</code> или <code>readlines()</code> происходит перемещение&nbsp;<strong>текущей позиции</strong> в конец файла. При использовании метода&nbsp;<code>readline()</code> текущая позиция перемещается на следующую строку файла.</p> 
  <p>При открытии файла текущая позиция всегда&nbsp;равна нулю&nbsp;– указывает на первый символ текста. При прочтении файла до конца с помощью вызова методов&nbsp;<code>read(), readlines()</code>&nbsp;позиция перемещается в конец файла и последующие чтения ничего не дают.</p> 
  <p><img alt="" height="49" src="https://ucarecdn.com/4b9c38db-3df1-4af7-a7f6-1a51bc5a1f41/" style="float: left;" width="49">Вызов методов&nbsp;<code>read(), readlines(), readline()</code>&nbsp;перемещает текущую позицию туда, где завершилось чтение. Для методов <code>read()</code> и <code>readlines()</code> это конец файла, для метода <code>readline()</code>&nbsp;– следующая строка после прочитанной.</p> 
  <p>Текущую&nbsp;позицию&nbsp;обычно называют&nbsp;"<strong>курсор"</strong>.&nbsp;</p> 
  <p>Предположим, у нас есть файл <code>languages.txt</code>. Когда мы его открываем,&nbsp;курсор находится в начале файла, в нулевой позиции, это выглядит примерно так:</p> 
  <p style="text-align: center;"><img alt="" height="404" src="https://ucarecdn.com/448f886e-cc06-470f-9cd5-6ba571341214/" width="554"></p> 
  <p>Если мы считаем две&nbsp;строки с помощью метода <code>readline()</code>:</p> 
  <pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
line2 = file.readline()

file.close()</code></pre> 
  <p>курсор переместится в начало&nbsp;третьей&nbsp;строки:</p> 
  <p style="text-align: center;"><img alt="" height="404" src="https://ucarecdn.com/b0362a51-bf99-469c-b306-8a831479b1e0/" width="551"></p> 
  <p>Чтение всегда происходит слева направо от&nbsp;курсора. Таким образом, если после двух вызовов метода <code>readline()</code> вызвать метод&nbsp;<code>read()</code>,&nbsp;он&nbsp;считает не весь файл, а только оставшиеся строки:</p> 
  <pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
line2 = file.readline()
remaining_lines = file.read()    # считывание начинается с 3 строки до конца файла

file.close()</code></pre> 
  <p>После того, как мы считали все строки файла, курсор находится в конце.</p> 
  <p style="text-align: center;"><img alt="" height="404" src="https://ucarecdn.com/95f1fee4-011b-4286-a5c7-62dddab0e54c/" width="549"></p> 
  <p>После завершения чтения мы больше не можем считать ни одного символа из файла. Все последующие вызовы методов&nbsp;<code>read()</code> или <code>readline()</code> будут приводить к считыванию пустой строки.</p> 
  <p>Для повторного чтения данных из файла, можно:</p> 
  <ul> 
   <li>переоткрыть файл, тогда курсор снова попадёт в начало;</li> 
   <li>переместить курсор с помощью файлового метода <code>seek()</code>.</li> 
  </ul> 
  <h3 style="text-align: center;">Файловый метод&nbsp;seek()</h3> 
  <p>Файловый метод <code>seek()</code> задаёт позицию курсора в байтах от начала файла. Чтобы перевести курсор в самое начало файла необходимо вызвать метод <code>seek()</code>, передав ему в качестве аргумента значение $0$.</p> 
  <p>Приведенный ниже код:</p> 
  <pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
file.seek(0)               # переводим курсор в самое начало
line2 = file.readline()

print(line1, line2)

file.close()</code></pre> 
  <p>выводит:</p> 
  <pre><code>Python
Python</code></pre> 
  <p>Метод <code>seek()</code> <strong>не очень</strong> полезен при работе с текстовыми файлами, так как не учитывает разделение текста на строки. А вот при работе с файлами в двоичном режиме умение работать с позицией и смещениями очень важно!</p> 
  <p><img alt="" height="49" src="https://ucarecdn.com/0c41708b-8782-49e0-ac25-61a21948c9d8/" style="float: left;" width="49">Будьте аккуратны с символами, использующими более $1$ байта (кириллица&nbsp;в кодировке&nbsp;<code>utf-8</code>), обращение к "промежуточному" байту может вызвать ошибку.</p> 
  <p>Если метод <code>seek()</code> устанавливает курсор (текущую позицию), то метод&nbsp;<code>tell()</code> получает ее.</p> 
  <p>Приведенный ниже код:</p> 
  <pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
print(file.tell())
line1 = file.readline()
print(file.tell())

file.close()</code></pre> 
  <p>выводит:</p> 
  <pre><code class="language-no-highlight">0
8</code></pre> 
  <p>В самом начале курсор (текущая позиция) равен&nbsp;нулю, после считывания первой строки, курсор смещается на $8$ байт (по байту на каждый из символов <code>'P', 'y', 't', 'h', 'o', 'n'</code> и&nbsp;два&nbsp;байта на символ перевода строки <code>'\n'</code>).</p> 
  <h2 style="text-align: center;">Менеджер&nbsp;контекста</h2> 
  <p>Как уже сказано, важно своевременно&nbsp;закрывать файлы&nbsp;с помощью метода <code>close()</code>.&nbsp;Закрытие файлов вручную, а также отдача закрытия на откуп среде исполнения, обладают&nbsp;существенным недостатком: если между открытием файла&nbsp;и его закрытием произойдёт ошибка,&nbsp;в лучшем случае файл окажется открыт слишком долго, а в худшем случае часть данных не сохранится.</p> 
  <p>Хочется иметь возможность автоматически закрывать файл сразу после окончания работы с ним и осуществлять закрытие даже при возникновении ошибки. Файловые объекты уже умеют работать в таком режиме, но для этого их нужно использовать как&nbsp;<strong>менеджеры контекста</strong>.</p> 
  <p>Менеджер контекста<em> </em>— объект, реализующий одноименный протокол. Объекты, реализующие этот протокол, позволяют использовать следующий специальный синтаксис:</p> 
  <pre><code class="language-python">with object as name:
    # Здесь нам доступен ресурс name.
    # Это тело with-блока.
# А здесь ресурс name уже освобождён, даже если в теле with-блока произошла ошибка.</code></pre> 
  <p>Весь код в теле&nbsp;<code>with</code>-блока работает "в контексте". Чаще всего контекст подразумевает выделение некоего ресурса, например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока возникло исключение.</p> 
  <p>Как только закончится код, оформленный с отступами в <code>with</code> (аналогичные отступы в циклах или функциях), это будет означать, что контекст закончился, и Python автоматически закроет файл.</p> 
  <p>Приведенный ниже код:</p> 
  <pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')

for line in file:
    print(line)

file.close()              # ручное закрытие файла

print('Файл закрыт')</code></pre> 
  <p>можно переписать в виде:</p> 
  <pre><code class="language-python">with open('languages.txt', 'r', encoding='utf-8') as file:
    for line in file:
        print(line)
                          # автоматическое закрытие файла
print('Файл закрыт')</code></pre> 
  <p>Обратите внимание: при использовании менеджера контекста&nbsp;не требуется использовать метод <code>close()</code>.</p> 
  <p><img alt="" height="49" src="https://ucarecdn.com/ebc24404-212c-49c4-9c0f-a292bc48f323/" width="49">&nbsp; &nbsp;При работе с файлами желательно всегда использовать менеджер&nbsp;контекста. Это&nbsp;делает&nbsp;программу надежнее.</p> 
  <h2 style="text-align: center;">Примечания</h2> 
  <p><strong>Примечание 1.</strong> Подробнее о файловом методе <code>seek()</code> можно&nbsp;почитать в&nbsp;<a href="https://docs.python.org/3/library/io.html#io.TextIOBase.seek" rel="nofollow noopener noreferrer" target="_blank">документации</a>.</p> 
  <p><strong>Примечание 2.&nbsp;</strong>В современных операционных системах файловый ввод-вывод устроен достаточно сложно. Для обеспечения максимального быстродействия чтения и записи в файлы, а также контроля&nbsp;безопасности&nbsp;этого процесса, большинство операционных систем&nbsp;не позволяют программам напрямую работать с диском.&nbsp;Операционная система предоставляет программам специальные объекты —&nbsp;файловые дескрипторы (функция <code>open()</code> возвращает как раз файловый дескриптор). Имея файловый дескриптор, можно записывать&nbsp;и читать&nbsp;данные, не задумываясь о файловой системе. Файловые дескрипторы удобны, но на создание каждого расходуется достаточно большое&nbsp;количество ресурсов. Поэтому у операционной системы есть общий лимит на количество&nbsp;одновременно использующихся&nbsp;файловых дескрипторов. И при этом каждая программа имеет свой собственный лимит. Как только программа исчерпает доступное ей количество дескрипторов, следующая попытка открыть очередной файл закончится с ошибкой.&nbsp;Программисту важно следить за тем, сколько файлов программа открывает в каждый момент и закрывает ли она их своевременно.&nbsp;Используйте менеджер контекста <code>with</code>&nbsp;и жизнь станет проще 😋.</p> 
  <p><strong>Примечание 3.</strong> С помощью менеджера&nbsp;контекста можно работать с несколькими файлами.</p> 
  <pre><code class="language-python">with open('input.txt', 'r') as input_file, open('output.txt', 'w') as output_file:
    # обработка файлов</code></pre> 
  <h2 style="text-align: right;"><strong>Made with&nbsp;💛 by&nbsp;BEEGEEK</strong></h2>
 </body>
</html>